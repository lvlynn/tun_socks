
===========分割线===============
当a为2的某个幂的值时（例如a=2^2=4，或a=2^3=8），有以下特点：

a = 4:  二进制： 0000 0100       从右起，第三位为1，剩下全为0;
a = 8:  二进制： 0000 1000       从右起，第四位为1, 剩下全为0；
a = 16: 二进制:  0001 0000       从右起，第五位为1，剩下全为0；

a - 1 = 3:  二进制： 0000 0011   从右起，第三位之前，全是1；
a - 1 = 7:  二进制： 0000 0111   从右起，第四位之前，全是1；
a - 1 = 15: 二进制： 0000 1111   从右起，第五位之前，全是1；

~(a - 1) = ~3:  二进制： 1111 1100   从右起，第二位之后，全是1；
~(a - 1) = ~7:  二进制： 1111 1000   从右起，第三位之后，全是1；
~(a - 1) = ~15: 二进制： 1111 0000   从右起，第四位之后，全是1；
(理解的关键点) 一个数，一定是这个数的二进制从右起第一个不为零的位所表示的数的整数倍
比如：

a = 12:  二进制： 0000 1100 
从右起，第一个不为零的位所表示的整数为 0000 0100 即 4
那么，a = 12 一定是 4 的整数倍

如果，我们需要任意的一个数a对4取整怎么办呢？很简单，只需要把a从右起的若干位置0就可以了。
比如：

a = 13: 二进制：0000 1101
向0000 0100 即 4 取整，只需要将 0000 1101从右起，前两位置0，即可得到，0000 1100 即12

这个置0的过程可以表达为0000 1101 &  1111 1100
而 1111 1100 = ~(4 - 1)，因此，13 对 4 取整的二进制运算即为：13 & ~(4 - 1)

可以看到，这样的二进制运算的结果是向下取整数倍。
但是，在申请内存时，只能比需求的大，而不能比需求的小，因此需要向上取整数倍：

对于一个任意的数d和一个2的任意次幂a：
d对a向下取整的二进制运算为：d & ~(a -1)
d对a向上取整的二进制运算为：(d + (a - 1)) & ~(a - 1)

相信到这里，已经可以很容易理解ngx_align这个宏的含义了

#define ngx_align(d, a)     (((d) + (a - 1)) & ~(a - 1))
